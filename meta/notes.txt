Ch1

Compile Time vs Runtime distinction
code in C has compile time and runtime. langauge constructs such as variables an functions lost after 
compile time. Become machine code

therefore, C has no metaprogramming or introspection because code lost after compilation
in C++, some language constructs survive compilation, therefore can ask object for its class.
In java, distinction between compile time and runtime less clear.

No compilation in Ruby. Dynamic, interpreted. metaprogramming
ruby simple language, but has subtleties.

"can an object call a private method on another object of the same class?
"how can you define class methods by importing a module?

all language complications derived from few rules

Ch2

metaprogramming manipulates language constructs such as classes, modules, instance variable, etc.
everything stems from "object model"

ruby executes code within a class as it would execute any other code

class D
def x; 'x'; end
end
class D
def y; 'y'; end
end

obj = D.new
obj.x
obj.y

The first time this code is run, class D does not exist, therefore it creates it
second time the code is run, class D exists so therefore the method is just monkey patched


therefore, class keyword in Ruby closer to scope operator than class declaration
creates classes that don't exist as a side effect. Main effect is to move into context o classes

therefore, can always open existing classes and modify them on the fly. "monkey patching"
or "Open Class"

class String
  def generic_method
  end
end

libraries or modules that are imported can use open classes.

problem is when overriding methods already existing on previous classes

in Java and other languages, there is conneciton between object's class and its instance variables.
in Ruby, there isn't.
instance variables like keys in hash. each ruby object can have different keysvalues pairs

enum.grep(pattern) -> returns array of every item that matches pattern

instance variables belong to object. methods belong to class.
similar to JS design. constructor function + methods on prototype

"MyClass has a method named my_method" -> wrong. implies MyClass.my_method()
"my_method is an instance method of MyClass" -> correct. 
instance method when talking about it in terms of class. method when talking about it in relation to object


String.instance_methods == "abc".methods  ---> true
String.methods == "abc".methods  ---> false


**** Classes are objects. ****

.class -> instance of what class
.superclass -> what inheriting from

Array.superclass   -> Object
Object.superclass   -> BasicObject
BasicObject.superclass   -> nil

In Ruby, Class and Module differ by three methods. [:new, :allocate, :superclass]

Module meant to be included somewhere in code. Class meant to be instantiated. 
can be used interchangeable though

Modules directories. Constants files. Scoped underneath

any reference beginning with uppercase letter, including names of classes and modules
is a constant

constants uniquely idenitifed by paths. constants use double colon as separator

module M
class C
X = 'a constant'
end
C::X # => "a constant"
end
M::C::X # => "a constant"

::Y => # ' a root level constant '


module M
  class C
    module M2
      Module.nesting # => [M::C::M2, M::C, M]
    end
  end
end

Constants and files very similar. 


module Rake
  class Task
    # ...

module Rake is a container of constants. therefore, namespaced

Rake::Task

***
Classes are just objects.Object are instance variables with link to class.
object's methods live in object's class.

Class object of class which is subclass of Module.


****
class TEXT -> class Text  --> error because monkeypatched module Text used by Action Mailer librray

load('motd.rb') -> loads variables and constants. variables get deleted, constants do not. pollutes namespace.
load('motd.rb', true) -> creates anonymous module to namespace constants, then deletes it

require ' ' -> imports libraries


***

When method in Ruby called,

1. Method Lookup
  - when called, ruby looks into object's class and finds method there. (obj. just holds instance variabels. methods live in classes)
  - receiver: object you call method on.  my_string.reverse()  my_string is receiver
  - ancestor chain: superclass path traverse

  - therefore, method lookup: ruby goes into receiver's class and climbs ancestors chain until it finds the method

  - if no superclass specified, implicitly inherits from Object
  - superclass is instance method on object classes for lookup
  - class.ancestors gives ancestor chain. Kernel included even though its a module
  - modules included in ancestral chain. module inserted above including class

  module M1
    def my_method
    end
  end

  class C
    include M1
  end

  class D < C; end

  D.ancestors => [D, C, M1, Object, Kernel, BasicObject]

  class C2
    prepend M2
  end

  class D2 < C2; end

  D2.ancestors => [D2, C2, M2, C2, Object, Kernel, BasicObject]

  If multiple modules included/prepended, only the first instance listed in ancestor array

  Kernel

  print method part of Kernel. class Object includes Kernel
  Every line of Ruby always executed inside object, so can call instance methods of Kernel from anywhere

  Adding method to Kernel means adding method everywhere

2. Method execution. Needs self.

  def my_method
    temp = @x + 1
    my_other_method(temp)
  end

  When executing this above method, need to determine to whome @x belongs and on what my_other_method called
  Every line of Ruby code executed inside an object - current object. referred to with self


  private

  cannot call private methods with explicit receiver. needs to be implicit self

  When not in a scope, Ruby self is main. main is an object also top-level context

  In a class, self is the class

  class MyClass
    self          #=>   MyClass
  end


  To circumvent monkeypatching problem,

  refinement with using

  module StringExtensions
    refine String do
      def reverse
        "esrever"
      end
    end
  end

  module StringStuff
    using StringExtensions
    "my_string".reverse # => "esrever"
  end

"my_string".reverse # => "gnirts_ym"



Chapter 3 Methods


Below code is repetitive:


class Computer
  def initialize(computer_id, data_source)
    @id = computer_id
    @data_source = data_source
  end

  def mouse
    info = @data_source.get_mouse_info(@id)
    price = @data_source.get_mouse_price(@id)
    result = "Mouse: #{info} ($#{price})"
    return "* #{result}" if price >= 100
    result
  end

  def cpu
    info = @data_source.get_cpu_info(@id)
    price = @data_source.get_cpu_price(@id)
    result = "Cpu: #{info} ($#{price})"
    return "* #{result}" if price >= 100
    result
  end

  def keyboard
    info = @data_source.get_keyboard_info(@id)
    price = @data_source.get_keyboard_price(@id)
    result = "Keyboard: #{info} ($#{price})"
    return "* #{result}" if price >= 100
    result
  end
end

Dyanmic Methods:
    - call and define methods dynamically

    - invoking methods is sending method to an object

    1.send( :+, 2)   #=> 3

ex:

Pry, the ruby command-line interpreter, is an object with interpreter's configuration

pry = Pry.new
pry.memory_size = 101
pry.memory_Size   # => 101


pry.refresh(:memory_size => 99, :quiet => false)
pry.memory_size # => 99
pry.quiet # => false

def refresh(options = {})
  defaults[:memory_size] = Pry.memory_size
  self.memory_size = options[:memory_size] if options[:memory_size]

  defaults[:quiet] = Pry.quiet
  self.quiet = options[:quiet] if options[:quiet]
end

lots of duplication for each attribute. instead:

def refresh(options = {}) 
  defaults = {}
  attributes = [ :input, :output, :commands, :print, :quiet,
                  :exception_handler, :hooks, :custom_compeltions,
                  :prompt, :memory_size, :extra_stick_locals ]

  attributes.each do |attribute|
    defaults[attribute] = Pry.send attribute
  end

  defaults.merge!(options).each do |key, value|
    send("#{key}=", value) if respond_to?("#{key}=")
  end

  true
end

send calls methods dynamically.
methods can also be defined dynamically

class MyClass
  define_method :my_method do |my_arg|
    my_arg * 3
  end
end

define_method ==>  can define name of method at runtime

first refactoring

class Computer
  def initialize(computer_id, data_source)
    @id = computer_id
    @data_source = data_source
  end

  def mouse
    component :mouse
  end

  def cpu
    component :cpu
  end

  def keyboard
    component :keyboard
  end

  def component(name)
    info = @data_source.send "get_#{name}_info", @id
    price = @data_source.send "get_#{name}_price", @id
    result = "#{name.capitalize}: #{info} ($#{price})"
    return "* #{result}" if price >= 100
    result
  end
end


class Computer
  def initialize(computer_id, data_source)
    @id = computer_id
    @data_source = data_source
  end

   def self.define_component(name)
    define_method(name) do
      info = @data_source.send "get_#{name}_info", @id
      price = @data_source.send "get_#{name}_price", @id
      result = "#{name.capitalize}: #{info} ($#{price})"
      return "* #{result}" if price >= 100
      result
    end
   end

   define_component :mouse
   define_component :cpu
   define_component :keyboard
end

data_source.methods.grep(/^get_(.*)_info$/) { Computer.define_component $1 }

Above two solutions based on Dynamic Dispatch (send) and Dynamic Methods

Next solution:

Ghost Methods and dynamic proxies

since no compiler to enforce method calls, can call a method that doesn't exist

class Lawyer; end
nick = Lawyer.new
nick.talk_simple

NoMethodError: undefined method 'talk_simple' for #<Lawyer:..."
BasicObject#method_missing 


class Lawyer
  def method_missing(method, *args)
    puts "You called: #{method}(#{args.join(', ')})"
    puts "(You also passed it a block)" if block_given?
  end
end

bob = Lawyer.new
bob.talk_simple('a', 'b') do
# a block
end

You called: talk_simple(a, b)
(You also passed it a block)

override:
  def method_missing()
  end

Dynamic Proxy - object that catches ghost methods and forwards them to another object

.responds_to?
.instance_methods
